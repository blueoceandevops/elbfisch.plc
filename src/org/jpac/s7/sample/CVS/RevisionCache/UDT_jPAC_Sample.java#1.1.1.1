/**
 * PROJECT   : jPac PLC communication library
 * MODULE    : WriteRequest.java
 * VERSION   : $Revision: $
 * DATE      : $Date: $
 * PURPOSE   : represents a write request
 * AUTHOR    : Bernd Schuster, MSK Gesellschaft fuer Automatisierung mbH, Schenefeld
 * REMARKS   : -
 * CHANGES   : CH#n <Kuerzel> <datum> <Beschreibung>
 *
 * This file is part of the jPac PLC communication library.
 * The jPac PLC communication library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The jPac PLC communication library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the jPac PLC communication library.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


/**
* PROJECT   : jPAC accessors for the tutorial
* MODULE    : UDT_jPAC_Sample.java 
* VERSION   : $Revision$
* DATE      : $Date$
* PURPOSE   : implements the S7 data item UDT_jPAC_Sample
* REMARKS   : this code was automatically generated by the struct generator
*             of the jPAC S7 communication library
* LOG       : $Log$
*
* The jPac S7 communication library is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* The jPac S7 communication library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with the jPac S7 communication library. If not, see <http://www.gnu.org/licenses/>.
*
*/

package org.jpac.s7.sample;

import org.jpac.IndexOutOfRangeException;
import org.jpac.plc.AddressException;
import org.jpac.plc.Connection;
import org.jpac.plc.Address;
import org.jpac.plc.Data;
import org.jpac.plc.LobRxTx;
import org.jpac.plc.WordRxTx;
import org.jpac.plc.BitRxTx;
import org.jpac.plc.ByteRxTx;
import org.jpac.plc.DwordRxTx;
import org.jpac.plc.IntRxTx;
import org.jpac.plc.DintRxTx;
import org.jpac.plc.StringRxTx;

public class UDT_jPAC_Sample extends LobRxTx{

    private BitRxTx 		bitValue;
    private ByteRxTx 		byteValue;
    private IntRxTx 		intValue;
    private DintRxTx 		dintValue;
    private WordRxTx 		wordValue;
    private DwordRxTx 		dwordValue;
    private ByteRxTx 		charValue;
    private StringRxTx 		stringValue;
    private ByteRxTx[] 		byteArray;
    private UDT1$0 		inlineStruct;
    private UDT_100 		udtValue;
    private UDT_100[] 		udtArray;

    //constructor for standalone use
    public UDT_jPAC_Sample(Connection conn, Address address) throws IndexOutOfRangeException{
        super(conn, address, 0, null);
        setData(conn.generateDataObject(getSize()));
    }

    //constructor for use inside a structure
    public UDT_jPAC_Sample(Connection conn, Address address, int dataOffset, Data data) throws IndexOutOfRangeException{
        super(conn, address, dataOffset, data);
    }

    protected void assertIndexRange(int IndexNumber, int setFirstIndex, int setLastIndex, int actualIndex) throws IndexOutOfRangeException{
        if (actualIndex < setFirstIndex || actualIndex > setLastIndex)
            throw new IndexOutOfRangeException("expecting [" + setFirstIndex + ".." + setLastIndex + "] for index" + IndexNumber + ", found: " + actualIndex);
    }

    public static int getSize(){
        return 112;
    }


    @SuppressWarnings("empty-statement")
    public BitRxTx getBitValue() throws AddressException, IndexOutOfRangeException{
        if (bitValue == null){
            int byteOffset = getAddress().getByteIndex() + 0;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setBitIndex(0);
            addr.setSize(BitRxTx.getSize());
            bitValue = new BitRxTx(getConnection(), addr, byteOffset, getData());
        }
        return bitValue;
    }

    @SuppressWarnings("empty-statement")
    public ByteRxTx getByteValue() throws AddressException, IndexOutOfRangeException{
        if (byteValue == null){
            int byteOffset = getAddress().getByteIndex() + 1;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(ByteRxTx.getSize());
            byteValue = new ByteRxTx(getConnection(), addr, byteOffset, getData());
        }
        return byteValue;
    }

    @SuppressWarnings("empty-statement")
    public IntRxTx getIntValue() throws AddressException, IndexOutOfRangeException{
        if (intValue == null){
            int byteOffset = getAddress().getByteIndex() + 2;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(IntRxTx.getSize());
            intValue = new IntRxTx(getConnection(), addr, byteOffset, getData());
        }
        return intValue;
    }

    @SuppressWarnings("empty-statement")
    public DintRxTx getDintValue() throws AddressException, IndexOutOfRangeException{
        if (dintValue == null){
            int byteOffset = getAddress().getByteIndex() + 4;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(DintRxTx.getSize());
            dintValue = new DintRxTx(getConnection(), addr, byteOffset, getData());
        }
        return dintValue;
    }

    @SuppressWarnings("empty-statement")
    public WordRxTx getWordValue() throws AddressException, IndexOutOfRangeException{
        if (wordValue == null){
            int byteOffset = getAddress().getByteIndex() + 8;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(WordRxTx.getSize());
            wordValue = new WordRxTx(getConnection(), addr, byteOffset, getData());
        }
        return wordValue;
    }

    @SuppressWarnings("empty-statement")
    public DwordRxTx getDwordValue() throws AddressException, IndexOutOfRangeException{
        if (dwordValue == null){
            int byteOffset = getAddress().getByteIndex() + 10;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(DwordRxTx.getSize());
            dwordValue = new DwordRxTx(getConnection(), addr, byteOffset, getData());
        }
        return dwordValue;
    }

    @SuppressWarnings("empty-statement")
    public ByteRxTx getCharValue() throws AddressException, IndexOutOfRangeException{
        if (charValue == null){
            int byteOffset = getAddress().getByteIndex() + 14;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(ByteRxTx.getSize());
            charValue = new ByteRxTx(getConnection(), addr, byteOffset, getData());
        }
        return charValue;
    }

    @SuppressWarnings("empty-statement")
    public StringRxTx getStringValue() throws AddressException, IndexOutOfRangeException{
        if (stringValue == null){
            int byteOffset = getAddress().getByteIndex() + 16;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(34);
            stringValue = new StringRxTx(getConnection(), addr, byteOffset, getData());
        }
        return stringValue;
    }

    @SuppressWarnings("empty-statement")
    public ByteRxTx getByteArray(int index1) throws AddressException, IndexOutOfRangeException{

        assertIndexRange(1, -5, 3, index1);

        if (byteArray == null){
            byteArray = new ByteRxTx[9];
        }
        //check, if the item already has been accessed
        if (byteArray[index1 - -5] == null){
            //if not, instantiate a new representation
            //and store it for subsequent uses
            int byteOffset = getAddress().getByteIndex() + 50 + ((index1 - -5)) * 1;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(ByteRxTx.getSize());
            byteArray[index1 - -5] = new ByteRxTx(getConnection(), addr, byteOffset, getData());
        }
        return byteArray[index1 - -5];
    }

    @SuppressWarnings("empty-statement")
    public UDT1$0 getInlineStruct() throws AddressException, IndexOutOfRangeException{
        if (inlineStruct == null){
            int byteOffset = getAddress().getByteIndex() + 60;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(UDT1$0.getSize());
            inlineStruct = new UDT1$0(getConnection(), addr, byteOffset, getData());
        }
        return inlineStruct;
    }

    @SuppressWarnings("empty-statement")
    public UDT_100 getUdtValue() throws AddressException, IndexOutOfRangeException{
        if (udtValue == null){
            int byteOffset = getAddress().getByteIndex() + 68;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(UDT_100.getSize());
            udtValue = new UDT_100(getConnection(), addr, byteOffset, getData());
        }
        return udtValue;
    }

    @SuppressWarnings("empty-statement")
    public UDT_100 getUdtArray(int index1) throws AddressException, IndexOutOfRangeException{

        assertIndexRange(1, 1, 10, index1);

        if (udtArray == null){
            udtArray = new UDT_100[10];
        }
        //check, if the item already has been accessed
        if (udtArray[index1 - 1] == null){
            //if not, instantiate a new representation
            //and store it for subsequent uses
            int byteOffset = getAddress().getByteIndex() + 72 + ((index1 - 1)) * 4;
            Address addr = null;
            try{addr = (Address)getAddress().clone();}catch(CloneNotSupportedException exc){};
            addr.setByteIndex(byteOffset);
            addr.setSize(UDT_100.getSize());
            udtArray[index1 - 1] = new UDT_100(getConnection(), addr, byteOffset, getData());
        }
        return udtArray[index1 - 1];
    }
}
